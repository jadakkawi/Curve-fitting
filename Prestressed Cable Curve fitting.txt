from os import chdirfrom geometric_functions import *import openpyxlimport pprintchdir("C:\\Users\\jgakkawi\\Desktop\\PT-DOS GEOM")wb = openpyxl.load_workbook('INPUT WB.xlsx')u_w_s_r = wb['UW COORDINATES']u_x_y_r = wb['XY TRANSFORM']u_y_z_r = wb['YZ TRANSFORM']output = []wb_new = openpyxl.Workbook()uw_sheet = wb_new.activeuw_sheet.title = "UW COORD"input_sheet = wb_new.create_sheet("INPUT", 0)# START of Copy input u-z to output workbookfor i in range(1, 17):    for j in 'ABCDEFGHI':        input_sheet[j + str(i)] = u_w_s_r[j + str(i)].value# END of Copy# START of analyses UW input and handles Curve fittingfor row in range(4, u_w_s_r.max_row):    u1 = u_w_s_r['B' + str(row)].value    w1 = u_w_s_r['C' + str(row)].value    s1 = u_w_s_r['D' + str(row)].value    r1 = u_w_s_r['F' + str(row)].value    u2 = u_w_s_r['B' + str(row + 1)].value    w2 = u_w_s_r['C' + str(row + 1)].value    s2 = u_w_s_r['D' + str(row + 1)].value    r2 = u_w_s_r['E' + str(row + 1)].value    out_nbr = u_w_s_r['I' + str(row)].value    if u2 is None:        break    elif w1 is None and s1 is None:        continue    elif r1 == "STRAIGHT":        if s1 is not None:            if u_w_s_r['B' + str(row + 2)].value is None:                for point in straight_line(u1, w1, s1, u2, out_nbr):                    output.append(point)            else:                for point in straight_line(u1, w1, s1, u2, out_nbr)[:-1]:                    output.append(point)            u_w_s_r['C' + str(row + 1)] = w1 + (s1/100)*(u2 - u1)            u_w_s_r['D' + str(row + 1)] = s1        elif w2 is not None:            s1 = (w2 - w1) / (u2 - u1)            s2 = s1            u_w_s_r['D' + str(row + 1)] = s1            if u_w_s_r['B' + str(row + 2)].value is None:                for point in straight_line(u1, w1, s1, u2, out_nbr):                    output.append(point)            else:                for point in straight_line(u1, w1, s1, u2, out_nbr)[:-1]:                    output.append(point)        elif s2 is not None:            if u_w_s_r['B' + str(row + 2)].value is None:                for point in straight_line(u1, w1, s2, u2, out_nbr):                    output.append(point)            else:                for point in straight_line(u1, w1, s2, u2, out_nbr)[:-1]:                    output.append(point)            u_w_s_r['C' + str(row + 1)] = w1 + (s2/100)*(u2 - u1)        elif u_w_s_r['F' + str(row + 1)].value is None:            u3 = u_w_s_r['B' + str(row + 2)].value            w3 = u_w_s_r['C' + str(row + 2)].value            s3 = u_w_s_r['D' + str(row + 2)].value            out_nbr_2 = u_w_s_r['I' + str(row + 1)].value            if None not in [u3, w3, s3]:                for point in straight_parabola_numeric(u1, w1, u2, u3, w3, s3, out_nbr, out_nbr_2)[:-1]:                    output.append(point)        else:            print("BAD STRAIGHT")    elif r1 is None:        if r2 is None:            if None not in [w1, s1, w2, s2]:                for point in standard_parabola(u1, w1, s1, u2, w2, s2, out_nbr)[:-1]:                    output.append(point)            elif u_w_s_r['F' + str(row + 1)].value == "STRAIGHT":                u3 = u_w_s_r['B' + str(row + 2)].value                w3 = u_w_s_r['C' + str(row + 2)].value                s3 = u_w_s_r['D' + str(row + 2)].value                out_nbr_2 = u_w_s_r['I' + str(row + 1)].value                if None not in [w2, w3]:                    s2 = (w3 - w2) / (u3 - u2)                    for point in standard_parabola(u1, w1, s1, u2, w2, s2, out_nbr)[:-1]:                        output.append(point)                elif None not in [w2, s3]:                    s2 = s3                    for point in standard_parabola(u1, w1, s1, u2, w2, s2, out_nbr)[:-1]:                        output.append(point)                elif None not in [s2, w3]:                    w2 = w3 - s2/100 * (u3 - u2)                    u_w_s_r['C' + str(row + 1)] = w2                    for point in standard_parabola(u1, w1, s1, u2, w2, s2, out_nbr)[:-1]:                        output.append(point)                elif None not in [w3, s3]:                    w2 = w3 - s3/100 * (u3 - u2)                    s2 = s3                    u_w_s_r['C' + str(row + 1)] = w2                    u_w_s_r['D' + str(row + 1)] = s3                    for point in standard_parabola(u1, w1, s1, u2, w2, s2, out_nbr)[:-1]:                        output.append(point)                elif w3 is not None:                    for point in parabola_straight_numeric(u1, w1, s1, u2, u3, w3, out_nbr, out_nbr_2):                        output.append(point)                    break            elif u_w_s_r['F' + str(row + 1)].value is None:                for point in standard_parabola(u1, w1, s1, u2, w2, s2, out_nbr)[:-1]:                    output.append(point)        if r2 is not None:            for point in parabola_arc(u1, w1, s1, u2, w2, s2, r2, out_nbr)[:-1]:                output.append(point)    elif r1 is not None:        if r2 is None:            if s2 is not None and w2 is not None:                for point in parabola_arc(u2, w2, s2, u1, w1, s1, r1, out_nbr)[:-1]:                    output.append(point)            elif u_w_s_r['F' + str(row + 1)].value == "STRAIGHT":                u3 = u_w_s_r['B' + str(row + 2)].value                w3 = u_w_s_r['C' + str(row + 2)].value                s3 = u_w_s_r['D' + str(row + 2)].value                if None not in [w2, w3]:                    s2 = (w3 - w2) / (u3 - u2)                    for point in parabola_arc(u2, w2, s2, u1, w1, s1, r1, out_nbr)[:-1]:                        output.append(point)                elif None not in [w2, s3]:                    s2 = s3                    for point in parabola_arc(u2, w2, s2, u1, w1, s1, r1, out_nbr)[:-1]:                        output.append(point)                elif None not in [s2, w3]:                    w2 = w3 - s2/100 * (u3 - u2)                    u_w_s_r['C' + str(row + 1)] = w2                    for point in parabola_arc(u2, w2, s2, u1, w1, s1, r1, out_nbr)[:-1]:                        output.append(point)                elif None not in [w3, s3]:                    w2 = w3 - s3/100 * (u3 - u2)                    s2 = s3                    u_w_s_r['C' + str(row + 1)] = w2                    u_w_s_r['D' + str(row + 1)] = s3                    for point in parabola_arc(u2, w2, s2, u1, w1, s1, r1, out_nbr)[:-1]:                        output.append(point)                elif w3 is not None:                    pass  # Must include arc_parabola_straight, but too much computation.        elif r2 is not None and r2 != "STRAIGHT":            pass  # Must include Double Radii elements        elif r2 == "STRAIGHT":            print("BAD RADII_STRAIGHT")pprint.pprint(output)# END of Curve Fitting Part# after "output" list is populated by u and w and s and r...# time to assign for each u a corresponding XY, center and radius# START of center and arc lengths collection for XY TRANSFORMlengths_XY = []radii_XY = []centers_XY = []start_XY = []end_XY = []for row in range(4, u_x_y_r.max_row):    x1 = u_x_y_r['C' + str(row)].value    y1 = u_x_y_r['D' + str(row)].value    r1 = u_x_y_r['E' + str(row)].value    x2 = u_x_y_r['C' + str(row + 1)].value    y2 = u_x_y_r['D' + str(row + 1)].value    if u_x_y_r['C4'].value is None:        break    if r1 is None:        break    start_XY.append([x1, y1])    end_XY.append([x2, y2])    if r1 == 0:        lengo = math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))        lengths_XY.append(lengo)        radii_XY.append('STRAIGHT')        centers_XY.append('STRAIGHT')    else:        mid = [(x1 + x2) / 2, (y1 + y2) / 2]        AI = math.sqrt(((x1-mid[0])**2)+((y1 - mid[1])**2))        ICsq = r1**2 - AI**2        S_AB = (y1 - y2)/(x1 - x2)        if r1 < 0:            y_center = math.sqrt(ICsq/(1+(S_AB**2)))+mid[1]        else:            y_center = - math.sqrt(ICsq/(1+(S_AB**2)))+mid[1]        x_center = - S_AB * (y_center-mid[1]) + mid[0]        center = [x_center, y_center]        v1 = [x1 - center[0], y1 - center[1], 0]        v2 = [x2 - center[0], y2 - center[1], 0]        tetta = angle_between(v1, v2)        lengths_XY.append(abs(r1) * tetta)        radii_XY.append(abs(r1))        centers_XY.append(center)# END of center and arc lengths collection# Now for each u in "output" list we assign an XY transform for the origin of w.# START of XY for each "u"for i in range(len(output)):    if len(lengths_XY) == 0:        output[i].append(output[i][0])        output[i].append(output[i][1])    else:        for j in range(len(lengths_XY) + 1):            if output[i][0] < sum(lengths_XY[: j + 1]):                if radii_XY[j] != 'STRAIGHT':                    u_local = output[i][0] - sum(lengths_XY[:j])                    theta_local = u_local / radii_XY[j]                    theta_cos = np.arccos((start_XY[j][0] - centers_XY[j][0]) / radii_XY[j])                    theta_sin = np.arcsin((start_XY[j][1] - centers_XY[j][1]) / radii_XY[j])                    theta = [theta_cos, - theta_cos, theta_sin]                    if theta_sin < 0:                        theta.append(-math.pi - theta_sin)                    else:                        theta.append(math.pi - theta_sin)                    for t in range(len(theta)):                        for y in range(t+1, len(theta)):                            if abs(theta[t]-theta[y]) < 0.05:                                theta_t = theta[t]                                break                        if abs(theta[t]-theta[y]) < 0.05:                            break                    if theta_t < 0:                        theta_final = theta_t + theta_local                    else:                        theta_final = theta_t - theta_local                    x = centers_XY[j][0] + (radii_XY[j] * math.cos(theta_final))                    y = centers_XY[j][1] + (radii_XY[j] * math.sin(theta_final))                    output[i].append(round(x, 4))                    output[i].append(round(y, 4))                else:                    u_local = output[i][0] - sum(lengths_XY[:j])                    ratio = u_local / lengths_XY[j]                    x = start_XY[j][0] + (end_XY[j][0] - start_XY[j][0]) * ratio                    y = start_XY[j][1] + (end_XY[j][1] - start_XY[j][1]) * ratio                    output[i].append(round(x, 4))                    output[i].append(round(y, 4))                break# END of XY for each "u"# Now we define the curve of the soffit so the cable could follow it.# START of center and arc lengths collection for YZ TRANSFORMlengths_YZ = []radii_YZ = []centers_YZ = []start_YZ = []end_YZ = []for row in range(4, u_y_z_r.max_row):    y1 = u_y_z_r['C' + str(row)].value    z1 = u_y_z_r['D' + str(row)].value    r1 = u_y_z_r['E' + str(row)].value    y2 = u_y_z_r['C' + str(row + 1)].value    z2 = u_y_z_r['D' + str(row + 1)].value    if u_y_z_r['C4'].value is None:        break    if r1 is None:        break    start_YZ.append([y1, z1])    end_YZ.append([y2, z2])    if r1 == 0:        lengo = math.sqrt(math.pow(y1 - y2, 2) + math.pow(z1 - z2, 2))        lengths_YZ.append(lengo)        radii_YZ.append('STRAIGHT')        centers_YZ.append('STRAIGHT')    else:        mid = [(y1 + y2) / 2, (z1 + z2) / 2]        AI = math.sqrt(((y1 - mid[0]) ** 2) + ((z1 - mid[1]) ** 2))        ICsq = r1**2 - AI**2        S_AB = (z1 - z2) / (y1 - y2)        if r1 < 0:            y_center = - math.sqrt(ICsq/(1+(S_AB**2)))+mid[1]        else:            y_center = math.sqrt(ICsq/(1+(S_AB**2)))+mid[1]        x_center = - S_AB * (y_center-mid[1]) + mid[0]        center = [x_center, y_center]        v1 = [y1 - center[0], z1 - center[1], 0]        v2 = [y2 - center[0], z2 - center[1], 0]        tetta = angle_between(v1, v2)        lengths_YZ.append(abs(r1) * tetta)        radii_YZ.append(abs(r1))        centers_YZ.append(center)# END of center and arc lengths collection# Now we have to get the offset curve after we apply the UV Transformation.# going to consider that V is constant now in order to lay out transform concept# any other form for V will get translated to equivalent  transverse offsets from soffit# STARTv = 0.1lengths_V = []radii_V = []start_V = []end_V = []if len(centers_YZ) == 0:    passelse:    for i in range(len(centers_YZ)):        start_y_prime = start_YZ[i][0] + (v / radii_YZ[i]) * (start_YZ[i][0] - centers_YZ[i][0])        start_z_prime = start_YZ[i][1] + (v / radii_YZ[i]) * (start_YZ[i][1] - centers_YZ[i][1])        start_V.append([start_y_prime, start_z_prime])        end_y_prime = end_YZ[i][0] + (v / radii_YZ[i]) * (end_YZ[i][0] - centers_YZ[i][0])        end_z_prime = end_YZ[i][1] + (v / radii_YZ[i]) * (end_YZ[i][1] - centers_YZ[i][1])        end_V.append([end_y_prime, end_z_prime])        radii_V.append(radii_YZ[i] + v)        lengths_V.append(lengths_YZ[i] * (radii_YZ[i] + v) / (radii_YZ[i]))# END# find y and w from offset of soffit curve# startfor i in range(len(output)):    if len(start_V) == 0:        output[i].append(v)        output[i].append(output[i][1])    else:        for j in range(len(start_V)):            if start_V[j][1] <= output[i][1] <= end_V[j][1] or end_V[j][1] <= output[i][1] <= start_V[j][1]:                yes = [centers_YZ[j][0] + math.sqrt(radii_V[j]**2 - (output[i][1] - centers_YZ[j][1])**2),                       centers_YZ[j][0] - math.sqrt(radii_V[j]**2 - (output[i][1] - centers_YZ[j][1])**2)]                y = yes[0] if start_V[j][0] <= yes[0] <= end_V[j][0] or end_V[j][0] <= yes[0]<=start_V[j][0] else yes[1]                output[i].append(y)                v1 = [start_V[j][0] - centers_YZ[j][0], start_V[j][1] - centers_YZ[j][1]]                v2 = [y - centers_YZ[j][0], output[i][1] - centers_YZ[j][1]]                thetta = angle_between(v1, v2)                output[i].append(thetta * abs(radii_YZ[j])+sum(lengths_YZ[:j]))# end# its time to change local y to global XY and finish with it.for i in range(len(output)):    for j in range(len(lengths_XY) + 1):        if output[i][0] < sum(lengths_XY[: j + 1]):            output[i].append(output[i][4] + output[i][6]/radii_XY[j]*(centers_XY[j][0] - output[i][4]))            output[i].append(output[i][5] + output[i][6]/radii_XY[j]*(centers_XY[j][1] - output[i][5]))# START of printing the output to exceluw_sheet['A1'] = "U COORD"uw_sheet['A2'] = "m"uw_sheet['B1'] = "W COORD"uw_sheet['B2'] = "m"uw_sheet['C1'] = "UW SLOPE"uw_sheet['C2'] = "Tan in %"uw_sheet['D1'] = "UW RAD"uw_sheet['D2'] = "m"uw_sheet['E1'] = "SPLINE"for it in range(len(output)):    uw_sheet['A' + str(it + 3)] = output[it][0]    uw_sheet['B' + str(it + 3)] = output[it][1]    uw_sheet['C' + str(it + 3)] = output[it][2]    uw_sheet['D' + str(it + 3)] = output[it][3]    uw_sheet['E' + str(it + 3)] = "{},{}".format(output[it][0], output[it][1])for col in 'ABCD':    uw_sheet.column_dimensions[col].width = 12uw_sheet.freeze_panes = 'A3'wb_new.save('{} UW COORD.xlsx'.format(wb['General Sheet']['B2'].value))# END of Output Printing